АЛГОРИТМ РАБОТЫ СИСТЕМЫ

ПРОБЛЕМА

Начальные условия:
1. Резервуары соеденены в цепочку.
2. Каждый резервуар имеет не более одного резервуара в цепочке до него и не более одного 
резервуара после.
3. Каждые два соседних резервуара соеденены насосом.
4. Первый насос (Н0) управляется вручную.
5. После работы насоса может быть запущен таймер.
6. Перекачивать в текущий резервуар можно только если вода в пред. резервуаре очищена
и есть что и куда перекачивать

С первого взгляда может сложиться впечатление, что система работает асинхронно:
как только таймер предыдущего насоса оттикал (вода очистилась) и можно перекачивать
в текущий, то запускаем насос. Но это не совсем так.
Допустим, что все баки НЕ пусты и все таймеры оттикали (вода готова). Рассмотрим такой случай:

Р0--1--Р1--1--Р2--1--Р3--1--Р4, где Р - резервуары, между которыми насосы - 0 - выкл, 1 - вкл.
    ^      ^      ^      ^
   Н0     Н1     Н2     Н3
   Т0     Т1     Т2     Т3

Согласно условию 6 данный случай не корректен. Корректо будет так:

Р0--1--Р1--0--Р2--1--Р3--0--Р4
    ^      ^      ^      ^
   Н0     Н1     Н2     Н3
   Т0     Т1     Т2     Т3

Т.е. если первый насос Н0 работает, то второй насос Н1 точно не работает
(вода в Р1 еще не готова). Третий насос Н2 работает, т.к. есть что качать и вода в Р2 готова 
(по условию случая). Следовательно идет перекачка в Р3 и вода в Р3 не готова, качать в Р4 
нельзая, т.е. Н3 выкл.

Прослеживается следующий паттерн: Н0 вкл -> Н1 выкл -> Н четный вкл -> Н нечетный выкл.

РЕШЕНИЕ

СВЯЗАНЫЙ СПИСОК

Под решение данной задачи подходит структура данных Связаный список.
В кратце, эта структура состоит из узлов (node), в которых хранятся данные и указатель (ссылка) 
на следующий узел:

struct Node {

Data data;  // <- Данные любого типа
Node* next; // <- Следующий узел

};

В отличии от массива, в связаном списке нельзя обратиться сразу к конкретному узлу (через оператор []),
можно перебрать узел за узлом и дойти до нужного.

В качестве узла в нашей задаче будут выступать два соседних резервуара (Tank) - исток и сток, 
насос (Pump) между ними и таймера (Timer).

struct Node {

Tank* source; // <- Резервуар-исток
Tank* drain;  // <- Резервуар-сток
Pump* pump;   // <- Насос между истоком и стоком
Timer* timer; // <- Таймер, который запускается после работы насоса

Node* netx;   // <- Следующий узел

};

АЛГОРИТМ

 _Узел0__        _Узел2__
/        \      /        \ 
Р0--Н0--Р1--Н1--Р2--Н2--Р3
        \_Узел1__/

Т.е. Р1 входит и в Узел0, и в Узел1; Р2 входит и в Узел1, и в Узел2.

Наименование узлов, если Р1--Н1--Р2 - текущий узел при работе алгоритма:

 Предыдущ        Следующ_
/        \      /        \ 
Р0--Н0--Р1--Н1--Р2--Н2--Р3
        \Текущий_/

С учетом разбиения на узлы и условий можно сформулировать так (начинаем с Узел0):
1) Если текущий узел работает (насос вкл или таймер еще не готов), то следующий узел выкл
не зависимо от того можно ли качать.
2) Если текущий узел не работает, то следующий может работать, если можно качать из истока в сток.
3) Первый узел ручной и не управляется алгоритмом.

Плюсы:
 - Абстрагированность от конкретного типа резервуара.
 - При желании можно выделить под узел отдельный МК и вести обработку показаний датчиков и таймера на 
 этом МК. Ведущий контроллер может обращаться к МК узла, например, по SPI.

Минусы:
 - Есть определенная последовательность обработки резервуаров. Инициатива за первым узлом и на него
 "равняются" последующие узлы. (Решаемо)
 - Если у резервуара более одного стока или истока (структура граф), то данный алгоритм не подходит 
(Не решаемо)
 
Решение первого минуса

Поскольку на практике важно, чтобы именно в последнем резервуаре, концентраторе, была вода, то можно
составить алгоритм обхода узлов в обратном порядке (с конца) и он будет звучать примерно так:
1) Если предыдущий узел работает (таймер еще не оттикал), то текущий точно выкл.
2) Если предыдущий узел не работает, то текущий может работать, если есть куда и что качать.
3) Если следующий узел работает, то текущий точно не работает.
4) Первый узел ручной и не управляется алгоритмом.

Пример работы алгоритма:

Изначально система имеет вид (все узлы готовы для работы):

 _Узел0_       _Узел2_
/       \     /       \ 
Р0--0--Р1--0--Р2--0--Р3
       \_Узел1_/
        
После прохода алгоритма по всем узлам:

 _Узел0_       _Узел2_
/       \     /       \ 
Р0--0--Р1--0--Р2--1--Р3
       \_Узел1_/    
        
Н2 - вкл, согласно п.2.
Н1 - выкл, согласно п.3.
Н0 - выкл, согласно п.4.

Таким образом, можно выбирать направление обхода в зависимости от первого ручного насоса:
Н0 вкл - прямое направление (приямок в приоритете), Н0 выкл - обратное (концентратор в приоритете)

Однако, в случае с концентратором необходимо качать, если он напоповину пуст, даже если в
предыдущем резервуаре (био) вода еще не готова. Это решается добавлением фунцкии к классу
резервуара, которая возвращает флаг необходимости срочной накачки:

virtual bool Tank::isNeedEmergencyPumping();

В случае концетратора он возвращает true, если нужна срочная накачка. Для всех остальных
резервуаров он возвращает false.
        

